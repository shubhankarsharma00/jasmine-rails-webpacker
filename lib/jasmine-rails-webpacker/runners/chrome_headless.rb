# frozen_string_literal: true

require 'socket'

module Jasmine
  module Runners
    class ChromeHeadless
      def initialize(formatter, jasmine_server_url, config)
        @formatter = formatter
        @jasmine_server_url = jasmine_server_url
        @config = config
      end

      def run
        chrome_server = IO.popen("\"#{chrome_binary}\" #{cli_options_string}")
        wait_for_chrome_to_start_debug_socket

        begin
          require 'chrome_remote'
        rescue LoadError
          raise 'Add "chrome_remote" you your Gemfile. To use chromeheadless we require this gem.'
        end

        chrome = wait_for { ChromeRemote.client }
        chrome.send_cmd 'Runtime.enable'
        chrome.send_cmd 'Page.navigate', url: jasmine_server_url
        result_received = false
        run_details = { 'random' => false }
        chrome.on 'Runtime.consoleAPICalled' do |params|
          if params['type'] == 'log'
            if params['args'][0] && params['args'][0]['value'] == 'jasmine:spec-result'
              results = JSON.parse(params['args'][1]['value'], max_nesting: false)
                .collect { |r| Result.new(r.merge!('show_full_stack_trace' => config.show_full_stack_trace)) }
              formatter.format(results)
            elsif params['args'][0] && params['args'][0]['value'] == 'jasmine:suite-result'
              results = JSON.parse(params['args'][1]['value'], max_nesting: false)
                .collect { |r| Result.new(r.merge!('show_full_stack_trace' => config.show_full_stack_trace)) }
              failures = results.select(&:failed?)
              formatter.format(failures) if failures.any?
            elsif params['args'][0] && params['args'][0]['value'] == 'jasmine:done'
              result_received = true
              run_details = JSON.parse(params['args'][1]['value'], max_nesting: false)
            elsif config.show_console_log
              $stdout.puts params['args'].collect { |e| e['value'] }.join(' ')
            end
          end
        end

        chrome.listen_until { result_received }
        formatter.done(run_details)
        chrome.send_cmd 'Browser.close'
        Process.kill('INT', chrome_server.pid)
      end

      def chrome_binary
        config.chrome_options[:binary] || find_chrome_binary
      end

      def cli_options_string
        cli_options = config.chrome_options[:cli] || {}
        cli_options.collect { |(k, v)| v ? "--#{k}=#{v}" : "--#{k}" }.join(' ')
      end

      def boot_js
        # Non-minified JS at the bottom of the file
        @boot_js ||= <<~JS.tr("\n", '')
          (function(){var l=console.log;jasmine.getEnv().addReporter({
          jasmineDone:function(n){l("jasmine:done",JSON.stringify(n))},
          specDone:function(n){l("jasmine:spec-result",JSON.stringify([].concat(n)))},
          suiteDone:function(n){l("jasmine:suite-result",JSON.stringify([].concat(n)))}
          })})();
        JS
      end

      private

      attr_reader :formatter, :jasmine_server_url, :config

      def find_chrome_binary
        potentials = [
          '/usr/bin/google-chrome',
          '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'
        ]
        potentials.detect { |path| File.file?(path) } || raise('No Chrome binary found')
      end

      def wait_for
        time = Time.now.to_i
        result = try_to { yield }

        while !result && Time.now.to_i - time < config.chrome_options[:startup_timeout]
          sleep(0.1)
          result = try_to { yield }
        end

        result
      end

      def try_to
        yield
      rescue
        nil
      end

      def wait_for_chrome_to_start_debug_socket
        open_socket = -> do
          conn = TCPSocket.new('localhost', 9222)
          conn.close
          true
        rescue
          nil
        message = "Chrome didn't seem to start the webSocketDebugger at port: 9222, timeout #{config.chrome_options[:startup_timeout]}sec"
        raise message unless wait_for(&open_socket)
      end
    end
  end
end

__END__

(function() {
  'use strict';
  // The ChromeHeadless runner will listen for events generated by these console
  // log calls.
  jasmine.getEnv().addReporter({
    jasmineDone: function(details) {
      console.log('jasmine:done', JSON.stringify(details));
    },

    specDone: function(results) {
      console.log('jasmine:spec-result', JSON.stringify([].concat(results)));
    },

    suiteDone: function(results) {
      console.log('jasmine:suite-result', JSON.stringify([].concat(results)));
    }
  });
})();

